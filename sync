#!/usr/bin/env bash
set -euo pipefail

# ─────────────────────────────────────────────────
# sync — bidirectional dotfile synchronization
# ─────────────────────────────────────────────────

REPO_DIR="$(cd "$(dirname "$0")" && pwd)"
HOME_DIR="$HOME"
VAULT_DIR="${REPO_DIR}/.sync_vault"

# 1Password config
OP_ITEM="Dotfiles Sync"
OP_VAULT="${DOTFILES_OP_VAULT:-Personal}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
RESET='\033[0m'

# Counters
SYNCED=0
SKIPPED=0
ERRORS=0

# Secrets backend: "op" or "file"
SECRETS_BACKEND=""

# Token patterns to detect secrets (safety net)
SECRET_PATTERNS='ghp_[A-Za-z0-9]|github_pat_[A-Za-z0-9]|npm_[A-Za-z0-9]{10}|sk-[A-Za-z0-9]{10}|ctx7sk-[A-Za-z0-9]|ghs_[A-Za-z0-9]|glpat-[A-Za-z0-9]|xox[bpsar]-[A-Za-z0-9]|ssh-ed25519 AAAA[A-Za-z0-9]'

# ─────────────────────────────────────────────────
# File mappings: repo_path:system_path:mode
# mode = copy | sensitive
# ─────────────────────────────────────────────────
MAPPINGS=(
  ".zshrc:${HOME_DIR}/.zshrc:sensitive"
  ".gitconfig:${HOME_DIR}/.gitconfig:sensitive"
  ".claude/settings.json:${HOME_DIR}/.claude/settings.json:copy"
  ".claude/mcp.json:${HOME_DIR}/.claude/mcp.json:copy"
  ".claude/agents/backend-architect.md:${HOME_DIR}/.claude/agents/backend-architect.md:copy"
  ".claude/agents/code-reviewer.md:${HOME_DIR}/.claude/agents/code-reviewer.md:copy"
  ".claude/agents/context-manager.md:${HOME_DIR}/.claude/agents/context-manager.md:copy"
  ".claude/agents/frontend-architect.md:${HOME_DIR}/.claude/agents/frontend-architect.md:copy"
  ".claude/agents/react-component-architect.md:${HOME_DIR}/.claude/agents/react-component-architect.md:copy"
  ".claude/agents/react-nextjs-expert.md:${HOME_DIR}/.claude/agents/react-nextjs-expert.md:copy"
  ".claude/commands/aw.md:${HOME_DIR}/.claude/commands/aw.md:copy"
  ".claude/hooks/pre-tool-use.js:${HOME_DIR}/.claude/hooks/pre-tool-use.js:copy"
  ".codex/config.toml:${HOME_DIR}/.codex/config.toml:sensitive"
  ".config/zed/settings.json:${HOME_DIR}/.config/zed/settings.json:copy"
  ".config/zed/keymap.json:${HOME_DIR}/.config/zed/keymap.json:copy"
  ".config/spaceship.zsh:${HOME_DIR}/.config/spaceship.zsh:copy"
  ".config/git/ignore:${HOME_DIR}/.config/git/ignore:copy"
  ".config/counselors/config.json:${HOME_DIR}/.config/counselors/config.json:copy"
  ".ssh/config:${HOME_DIR}/.ssh/config:sensitive"
)

# ─────────────────────────────────────────────────
# Helpers
# ─────────────────────────────────────────────────

cleanup() {
  printf "\n${DIM}Interrupted. ${SYNCED} synced, ${SKIPPED} skipped, ${ERRORS} errors.${RESET}\n"
  exit 130
}
trap cleanup SIGINT

parse_mapping() {
  local mapping="$1"
  REPO_PATH="${mapping%%:*}"
  local rest="${mapping#*:}"
  SYS_PATH="${rest%%:*}"
  MODE="${rest##*:}"
}

file_status() {
  local repo_file="${REPO_DIR}/${1}"
  local sys_file="$2"

  if [[ ! -f "$repo_file" ]] && [[ ! -f "$sys_file" ]]; then
    echo "missing_both"
  elif [[ ! -f "$repo_file" ]]; then
    echo "missing_repo"
  elif [[ ! -f "$sys_file" ]]; then
    echo "missing_system"
  elif diff -q "$repo_file" "$sys_file" &>/dev/null; then
    echo "synced"
  else
    echo "diverged"
  fi
}

status_color() {
  case "$1" in
    synced)        printf "${GREEN}✓ synced${RESET}" ;;
    diverged)      printf "${YELLOW}~ diverged${RESET}" ;;
    missing_repo)  printf "${RED}✗ missing in repo${RESET}" ;;
    missing_system) printf "${RED}✗ missing on system${RESET}" ;;
    missing_both)  printf "${RED}✗ missing both${RESET}" ;;
  esac
}

has_secrets() {
  grep -qE "$SECRET_PATTERNS" "$1" 2>/dev/null
}

show_diff() {
  local repo_file="${REPO_DIR}/${1}"
  local sys_file="$2"
  local lines="${3:-20}"

  if [[ -f "$repo_file" ]] && [[ -f "$sys_file" ]]; then
    diff --color=always -u "$repo_file" "$sys_file" | head -n "$lines" || true
    local total
    total=$(diff -u "$repo_file" "$sys_file" 2>/dev/null | wc -l | tr -d ' ')
    if (( total > lines )); then
      printf "${DIM}  ... %d more lines (showing %d/%d)${RESET}\n" $((total - lines)) "$lines" "$total"
    fi
  fi
}

ensure_parent_dir() {
  local dir
  dir="$(dirname "$1")"
  if [[ ! -d "$dir" ]]; then
    mkdir -p "$dir"
    printf "  ${DIM}Created directory: %s${RESET}\n" "$dir"
  fi
}

is_token_var() {
  local var="$1"
  case "$var" in
    *_TOKEN|*_SECRET|*_API_KEY|*_APIKEY|*_KEY) return 0 ;;
    TOKEN|SECRET|API_KEY|APIKEY) return 0 ;;
    *) return 1 ;;
  esac
}

# ─────────────────────────────────────────────────
# 1Password CLI backend
# ─────────────────────────────────────────────────

OP_ITEM_ENSURED=false

op_check() {
  if ! command -v op &>/dev/null; then
    return 1
  fi
  if ! op whoami &>/dev/null 2>&1; then
    return 2
  fi
  return 0
}

op_ensure_item() {
  if [[ "$OP_ITEM_ENSURED" == true ]]; then
    return 0
  fi
  if ! op item get "$OP_ITEM" --vault "$OP_VAULT" &>/dev/null 2>&1; then
    op item create \
      --category securenote \
      --title "$OP_ITEM" \
      --vault "$OP_VAULT" &>/dev/null
    printf "  ${GREEN}✓${RESET} Created 1Password item: ${BOLD}%s${RESET} in vault ${BOLD}%s${RESET}\n" "$OP_ITEM" "$OP_VAULT"
  fi
  OP_ITEM_ENSURED=true
}

op_save() {
  local section="$1"
  local field="$2"
  local value="$3"

  op_ensure_item

  # base64-encode to safely handle multi-line values and special chars
  local encoded
  encoded="$(printf '%s' "$value" | base64 | tr -d '\n')"

  op item edit "$OP_ITEM" --vault "$OP_VAULT" \
    "${section}.${field}[concealed]=${encoded}" &>/dev/null
}

op_get() {
  local section="$1"
  local field="$2"
  local encoded

  encoded="$(op read "op://${OP_VAULT}/${OP_ITEM}/${section}/${field}" 2>/dev/null || true)"
  if [[ -n "$encoded" ]]; then
    printf '%s' "$encoded" | base64 -d 2>/dev/null
    return 0
  fi
  return 1
}

# ─────────────────────────────────────────────────
# File-based vault (fallback)
# ─────────────────────────────────────────────────

vault_save() {
  local category="$1"
  local key="$2"
  local value="$3"
  local dir="${VAULT_DIR}/${category}"
  mkdir -p "$dir"
  if [[ -n "$value" ]]; then
    printf '%s\n' "$value" > "${dir}/${key}"
  fi
}

vault_get() {
  local category="$1"
  local key="$2"
  local file="${VAULT_DIR}/${category}/${key}"
  if [[ -f "$file" && -s "$file" ]]; then
    cat "$file"
    return 0
  fi
  return 1
}

vault_clear_category() {
  local category="$1"
  rm -rf "${VAULT_DIR:?}/${category}"
}

# ─────────────────────────────────────────────────
# Secrets abstraction layer
# ─────────────────────────────────────────────────

secrets_init() {
  if op_check; then
    SECRETS_BACKEND="op"
  else
    SECRETS_BACKEND="file"
  fi
}

secrets_save() {
  local category="$1"
  local key="$2"
  local value="$3"

  case "$SECRETS_BACKEND" in
    op)
      if ! op_save "$category" "$key" "$value"; then
        # Fall back to file if op fails
        vault_save "$category" "$key" "$value"
      fi
      ;;
    file)
      vault_save "$category" "$key" "$value"
      ;;
  esac
}

secrets_get() {
  local category="$1"
  local key="$2"

  case "$SECRETS_BACKEND" in
    op)
      local result
      result="$(op_get "$category" "$key" 2>/dev/null || true)"
      if [[ -n "$result" ]]; then
        echo "$result"
        return 0
      fi
      # Fall back to file vault
      vault_get "$category" "$key" 2>/dev/null
      ;;
    file)
      vault_get "$category" "$key" 2>/dev/null
      ;;
  esac
}

# ─────────────────────────────────────────────────
# .sync_config INI parser (op:// reference fallback)
# ─────────────────────────────────────────────────

SYNC_CONFIG="${REPO_DIR}/.sync_config"

config_get() {
  local section="$1"
  local key="$2"

  if [[ ! -f "$SYNC_CONFIG" ]]; then
    return 1
  fi

  local in_section=false
  local value=""

  while IFS= read -r line || [[ -n "$line" ]]; do
    # Strip leading/trailing whitespace
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%"${line##*[![:space:]]}"}"

    # Skip empty lines and comments
    [[ -z "$line" || "$line" == \#* ]] && continue

    # Section header
    if [[ "$line" =~ ^\[([a-zA-Z0-9_]+)\]$ ]]; then
      if [[ "${BASH_REMATCH[1]}" == "$section" ]]; then
        in_section=true
      else
        in_section=false
      fi
      continue
    fi

    # Key = value in our section
    if [[ "$in_section" == true && "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*=[[:space:]]*(.+)$ ]]; then
      local found_key="${BASH_REMATCH[1]}"
      local found_val="${BASH_REMATCH[2]}"

      if [[ "$found_key" == "$key" ]]; then
        # Resolve op:// references via 1Password CLI
        if [[ "$found_val" == op://* ]]; then
          if command -v op &>/dev/null; then
            value="$(op read "$found_val" 2>/dev/null || true)"
          fi
        else
          value="$found_val"
        fi

        if [[ -n "$value" ]]; then
          printf '%s' "$value"
          return 0
        fi
        return 1
      fi
    fi
  done < "$SYNC_CONFIG"

  return 1
}

print_secrets_status() {
  printf "\n${BOLD}Secrets:${RESET} "
  case "$SECRETS_BACKEND" in
    op)
      printf "${GREEN}1Password${RESET} ${DIM}(item: \"%s\" in vault \"%s\")${RESET}\n" "$OP_ITEM" "$OP_VAULT"
      ;;
    file)
      printf "${YELLOW}local vault${RESET} ${DIM}(%s)${RESET}\n" "$VAULT_DIR"
      if ! command -v op &>/dev/null; then
        printf "  ${DIM}Install 1password-cli for encrypted cross-machine storage:${RESET}\n"
        printf "  ${DIM}  brew install --cask 1password-cli${RESET}\n"
      else
        printf "  ${DIM}Sign in to 1Password CLI for encrypted storage:${RESET}\n"
        printf "  ${DIM}  eval \$(op signin)${RESET}\n"
      fi
      ;;
  esac

  if [[ -f "$SYNC_CONFIG" ]]; then
    printf "${BOLD}Config:${RESET}  ${GREEN}✓${RESET} ${DIM}.sync_config found (op:// fallback enabled)${RESET}\n"
  else
    printf "${BOLD}Config:${RESET}  ${DIM}.sync_config not found (no op:// fallback)${RESET}\n"
  fi
}

# ─────────────────────────────────────────────────
# Token sanitization (pull: system → repo)
#
# Strips real tokens, replaces with placeholders,
# and saves real values to secrets backend.
# ─────────────────────────────────────────────────

sanitize_for_repo() {
  local repo_path="$1"
  local src="$2"

  case "$repo_path" in
    .zshrc)       sanitize_zshrc "$src" ;;
    .gitconfig)   sanitize_gitconfig "$src" ;;
    .codex/config.toml) sanitize_codex "$src" ;;
    .ssh/config)  cat "$src" ;;
    *)            cat "$src" ;;
  esac
}

sanitize_zshrc() {
  local src="$1"
  local seen=":"
  local tmpdir
  tmpdir="$(mktemp -d)"

  while IFS= read -r line || [[ -n "$line" ]]; do
    local var=""
    if [[ "$line" =~ ^[#[:space:]]*(export[[:space:]]+([A-Z_]+)=) ]]; then
      var="${BASH_REMATCH[2]}"
    fi

    if [[ -n "$var" ]] && is_token_var "$var"; then
      # Accumulate lines per token in temp files
      printf '%s\n' "$line" >> "${tmpdir}/${var}"

      # Emit placeholder once per variable
      if [[ ":$seen:" != *":$var:"* ]]; then
        seen="${seen}${var}:"
        local placeholder
        placeholder="$(echo "$var" | tr '[:upper:]' '[:lower:]')"
        echo "# export ${var}=your_${placeholder}_here"
      fi
    elif [[ "$line" =~ ^#[[:space:]]*envs ]]; then
      echo "# envs - ADD YOUR OWN TOKENS HERE"
    else
      echo "$line"
    fi
  done < "$src"

  # Save all accumulated token values to secrets backend
  for f in "${tmpdir}"/*; do
    [[ -f "$f" ]] || continue
    local key value
    key="$(basename "$f")"
    value="$(cat "$f")"
    # Strip trailing newline from value for clean storage
    value="${value%$'\n'}"
    secrets_save "zshrc" "$key" "$value"
  done

  rm -rf "$tmpdir"
}

sanitize_gitconfig() {
  local src="$1"

  # Save real values
  local val
  val="$(git config --file "$src" user.signingkey 2>/dev/null || true)"
  [[ -n "$val" ]] && secrets_save "gitconfig" "signingkey" "$val"
  val="$(git config --file "$src" user.name 2>/dev/null || true)"
  [[ -n "$val" ]] && secrets_save "gitconfig" "name" "$val"
  val="$(git config --file "$src" user.email 2>/dev/null || true)"
  [[ -n "$val" ]] && secrets_save "gitconfig" "email" "$val"
  val="$(git config --file "$src" core.excludesfile 2>/dev/null || true)"
  [[ -n "$val" ]] && secrets_save "gitconfig" "excludesfile" "$val"

  # Sanitize output
  sed -E \
    -e 's/^([[:space:]]*signingkey = ).+$/\1signingkey/' \
    -e 's/^([[:space:]]*name = ).+$/\1Your Name/' \
    -e 's/^([[:space:]]*email = ).+$/\1your@email.com/' \
    -e 's|^([[:space:]]*excludesfile = /Users/)[^/]+(/.*)|\1USER_NAME\2|' \
    "$src"
}

sanitize_codex() {
  local src="$1"

  # Save real API key
  local api_key
  api_key="$(grep -oE 'CONTEXT7_API_KEY[[:space:]]*=[[:space:]]*"[^"]*"' "$src" 2>/dev/null | grep -oE '"[^"]+"' | tail -1 | tr -d '"' || true)"
  if [[ -n "$api_key" && "$api_key" != "CONTEXT7_API_KEY" ]]; then
    secrets_save "codex" "CONTEXT7_API_KEY" "$api_key"
  fi

  # Sanitize output
  sed -E \
    -e 's/(CONTEXT7_API_KEY[[:space:]]*=[[:space:]]*)"[^"]*"/\1"CONTEXT7_API_KEY"/' \
    "$src"
}

# ─────────────────────────────────────────────────
# Token restoration (push: repo → system)
#
# Takes the repo file (placeholders) and fills in
# real values from secrets backend (primary) or
# current system file (fallback).
# ─────────────────────────────────────────────────

restore_for_system() {
  local repo_path="$1"
  local repo_file="$2"
  local sys_file="$3"

  case "$repo_path" in
    .zshrc)             restore_zshrc "$repo_file" "$sys_file" ;;
    .gitconfig)         restore_gitconfig "$repo_file" "$sys_file" ;;
    .codex/config.toml) restore_codex "$repo_file" "$sys_file" ;;
    .ssh/config)        cat "$repo_file" ;;
    *)                  cat "$repo_file" ;;
  esac
}

restore_zshrc() {
  local repo_file="$1"
  local sys_file="$2"

  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" =~ ^#[[:space:]]*export[[:space:]]+([A-Z_]+)=your_.*_here$ ]]; then
      local var="${BASH_REMATCH[1]}"
      local restored=""

      # Try secrets backend first
      restored="$(secrets_get zshrc "$var" 2>/dev/null || true)"

      # Fall back to system file
      if [[ -z "$restored" && -f "$sys_file" ]]; then
        restored="$(grep -E "^[#[:space:]]*(export[[:space:]]+${var}=)" "$sys_file" 2>/dev/null || true)"
      fi

      # Fall back to .sync_config op:// references
      if [[ -z "$restored" ]]; then
        local config_val
        config_val="$(config_get zshrc "$var" 2>/dev/null || true)"
        if [[ -n "$config_val" ]]; then
          restored="export ${var}=${config_val}"
        fi
      fi

      if [[ -n "$restored" ]]; then
        echo "$restored"
      else
        echo "$line"
      fi
    elif [[ "$line" == "# envs - ADD YOUR OWN TOKENS HERE" ]]; then
      echo "# envs"
    else
      echo "$line"
    fi
  done < "$repo_file"
}

restore_gitconfig() {
  local repo_file="$1"
  local sys_file="$2"
  local tmpfile
  tmpfile="$(mktemp)"
  cp "$repo_file" "$tmpfile"

  # Read from secrets backend, fall back to system file
  local signingkey name email excludesfile

  signingkey="$(secrets_get gitconfig signingkey 2>/dev/null || true)"
  if [[ -z "$signingkey" && -f "$sys_file" ]]; then
    signingkey="$(git config --file "$sys_file" user.signingkey 2>/dev/null || true)"
  fi
  if [[ -z "$signingkey" ]]; then
    signingkey="$(config_get gitconfig signingkey 2>/dev/null || true)"
  fi

  name="$(secrets_get gitconfig name 2>/dev/null || true)"
  if [[ -z "$name" && -f "$sys_file" ]]; then
    name="$(git config --file "$sys_file" user.name 2>/dev/null || true)"
  fi
  if [[ -z "$name" ]]; then
    name="$(config_get gitconfig name 2>/dev/null || true)"
  fi

  email="$(secrets_get gitconfig email 2>/dev/null || true)"
  if [[ -z "$email" && -f "$sys_file" ]]; then
    email="$(git config --file "$sys_file" user.email 2>/dev/null || true)"
  fi
  if [[ -z "$email" ]]; then
    email="$(config_get gitconfig email 2>/dev/null || true)"
  fi

  excludesfile="$(secrets_get gitconfig excludesfile 2>/dev/null || true)"
  if [[ -z "$excludesfile" && -f "$sys_file" ]]; then
    excludesfile="$(git config --file "$sys_file" core.excludesfile 2>/dev/null || true)"
  fi
  if [[ -z "$excludesfile" ]]; then
    excludesfile="$(config_get gitconfig excludesfile 2>/dev/null || true)"
  fi

  [[ -n "$signingkey" ]] && git config --file "$tmpfile" user.signingkey "$signingkey"
  [[ -n "$name" ]] && git config --file "$tmpfile" user.name "$name"
  [[ -n "$email" ]] && git config --file "$tmpfile" user.email "$email"
  [[ -n "$excludesfile" ]] && git config --file "$tmpfile" core.excludesfile "$excludesfile"

  cat "$tmpfile"
  rm -f "$tmpfile"
}

restore_codex() {
  local repo_file="$1"
  local sys_file="$2"

  local api_key
  api_key="$(secrets_get codex CONTEXT7_API_KEY 2>/dev/null || true)"

  if [[ -z "$api_key" || "$api_key" == "CONTEXT7_API_KEY" ]]; then
    if [[ -f "$sys_file" ]]; then
      api_key="$(grep -oE 'CONTEXT7_API_KEY[[:space:]]*=[[:space:]]*"[^"]*"' "$sys_file" 2>/dev/null | grep -oE '"[^"]+"' | tail -1 | tr -d '"' || true)"
    fi
  fi

  if [[ -z "$api_key" || "$api_key" == "CONTEXT7_API_KEY" ]]; then
    api_key="$(config_get codex CONTEXT7_API_KEY 2>/dev/null || true)"
  fi

  if [[ -n "$api_key" && "$api_key" != "CONTEXT7_API_KEY" ]]; then
    sed "s|CONTEXT7_API_KEY = \"CONTEXT7_API_KEY\"|CONTEXT7_API_KEY = \"${api_key}\"|" "$repo_file"
  else
    cat "$repo_file"
  fi
}

# ─────────────────────────────────────────────────
# Smart copy: handles sanitization/restoration
# ─────────────────────────────────────────────────

push_to_system() {
  local repo_path="$1"
  local mode="$2"
  local repo_file="${REPO_DIR}/${repo_path}"
  local sys_file="$3"

  ensure_parent_dir "$sys_file"

  if [[ "$mode" == "sensitive" ]]; then
    restore_for_system "$repo_path" "$repo_file" "$sys_file" > "${sys_file}.sync_tmp"
    mv "${sys_file}.sync_tmp" "$sys_file"
  else
    cp "$repo_file" "$sys_file"
  fi
}

pull_to_repo() {
  local repo_path="$1"
  local mode="$2"
  local sys_file="$3"
  local repo_file="${REPO_DIR}/${repo_path}"

  ensure_parent_dir "$repo_file"

  if [[ "$mode" == "sensitive" ]]; then
    sanitize_for_repo "$repo_path" "$sys_file" > "${repo_file}.sync_tmp"
    mv "${repo_file}.sync_tmp" "$repo_file"

    if has_secrets "$repo_file"; then
      printf "  ${RED}⚠ WARNING: Secrets detected after sanitization in %s${RESET}\n" "$repo_path"
      printf "  ${RED}  Review the file before committing!${RESET}\n"
    fi
  else
    cp "$sys_file" "$repo_file"
  fi
}

# ─────────────────────────────────────────────────
# AGENTS.md / CLAUDE.md symlink
# ─────────────────────────────────────────────────

check_agents_symlink() {
  local agents_repo="${REPO_DIR}/AGENTS.md"
  local agents_home="${HOME_DIR}/AGENTS.md"
  local claude_link="${HOME_DIR}/.claude/CLAUDE.md"

  printf "\n${BOLD}AGENTS.md symlink health:${RESET}\n"

  if [[ -f "$agents_repo" ]]; then
    if [[ -f "$agents_home" ]]; then
      if diff -q "$agents_repo" "$agents_home" &>/dev/null; then
        printf "  ${GREEN}✓${RESET} ~/AGENTS.md in sync with repo\n"
      else
        printf "  ${YELLOW}~${RESET} ~/AGENTS.md diverged from repo\n"
      fi
    else
      printf "  ${RED}✗${RESET} ~/AGENTS.md missing\n"
    fi
  else
    printf "  ${RED}✗${RESET} AGENTS.md missing from repo\n"
  fi

  if [[ -L "$claude_link" ]]; then
    local target
    target="$(readlink "$claude_link")"
    if [[ "$target" == "${HOME_DIR}/AGENTS.md" ]] || [[ "$target" == "$agents_home" ]]; then
      printf "  ${GREEN}✓${RESET} ~/.claude/CLAUDE.md -> ~/AGENTS.md\n"
    else
      printf "  ${YELLOW}~${RESET} ~/.claude/CLAUDE.md -> %s (unexpected target)\n" "$target"
    fi
  elif [[ -f "$claude_link" ]]; then
    printf "  ${RED}✗${RESET} ~/.claude/CLAUDE.md is a regular file (should be symlink)\n"
  else
    printf "  ${RED}✗${RESET} ~/.claude/CLAUDE.md symlink missing\n"
  fi
}

sync_agents_md() {
  local direction="$1"
  local agents_repo="${REPO_DIR}/AGENTS.md"
  local agents_home="${HOME_DIR}/AGENTS.md"
  local claude_link="${HOME_DIR}/.claude/CLAUDE.md"

  case "$direction" in
    push)
      if [[ -f "$agents_repo" ]]; then
        cp "$agents_repo" "$agents_home"
        printf "  ${GREEN}✓${RESET} Copied AGENTS.md -> ~/AGENTS.md\n"
      fi
      ;;
    pull)
      if [[ -f "$agents_home" ]]; then
        cp "$agents_home" "$agents_repo"
        printf "  ${GREEN}✓${RESET} Copied ~/AGENTS.md -> repo AGENTS.md\n"
      fi
      ;;
  esac

  if [[ ! -L "$claude_link" ]]; then
    rm -f "$claude_link"
    mkdir -p "$(dirname "$claude_link")"
    ln -s "${HOME_DIR}/AGENTS.md" "$claude_link"
    printf "  ${GREEN}✓${RESET} Created symlink ~/.claude/CLAUDE.md -> ~/AGENTS.md\n"
  fi
}

# ─────────────────────────────────────────────────
# Claude Code skills tracking
# ─────────────────────────────────────────────────

SKILLS_FILE="${REPO_DIR}/skills.txt"
SKILLS_DIR="${HOME_DIR}/.claude/skills"

sync_skills() {
  local direction="$1"

  case "$direction" in
    pull)
      if [[ ! -d "$SKILLS_DIR" ]]; then
        printf "  ${DIM}= skills (none installed)${RESET}\n"
        return
      fi

      local names=()
      for link in "${SKILLS_DIR}"/*/; do
        [[ -d "$link" ]] || continue
        names+=("$(basename "$link")")
      done

      if (( ${#names[@]} == 0 )); then
        printf "  ${DIM}= skills (none installed)${RESET}\n"
        return
      fi

      printf '%s\n' "${names[@]}" | sort > "$SKILLS_FILE"
      printf "  ${GREEN}✓${RESET} Saved %d skill names to skills.txt\n" "${#names[@]}"
      ;;

    push)
      if [[ ! -f "$SKILLS_FILE" ]]; then
        return
      fi

      local missing=()
      while IFS= read -r skill || [[ -n "$skill" ]]; do
        [[ -z "$skill" || "$skill" == \#* ]] && continue
        if [[ ! -d "${SKILLS_DIR}/${skill}" ]]; then
          missing+=("$skill")
        fi
      done < "$SKILLS_FILE"

      if (( ${#missing[@]} == 0 )); then
        printf "  ${DIM}= skills (all %d installed)${RESET}\n" "$(wc -l < "$SKILLS_FILE" | tr -d ' ')"
      else
        printf "  ${YELLOW}⚠${RESET} %d missing skills — install with:\n" "${#missing[@]}"
        for skill in "${missing[@]}"; do
          printf "    ${DIM}claude install-skill %s${RESET}\n" "$skill"
        done
      fi
      ;;

    status)
      if [[ ! -f "$SKILLS_FILE" ]]; then
        printf "%-45s ${DIM}%-6s${RESET} " "skills.txt" "list"
        printf "${RED}✗ missing in repo${RESET}\n"
        return
      fi

      local total installed=0 missing=0
      total="$(wc -l < "$SKILLS_FILE" | tr -d ' ')"

      while IFS= read -r skill || [[ -n "$skill" ]]; do
        [[ -z "$skill" || "$skill" == \#* ]] && continue
        if [[ -d "${SKILLS_DIR}/${skill}" ]]; then
          ((installed++))
        else
          ((missing++))
        fi
      done < "$SKILLS_FILE"

      printf "%-45s ${DIM}%-6s${RESET} " "skills.txt" "list"
      if (( missing == 0 )); then
        printf "${GREEN}✓ %d skills synced${RESET}\n" "$total"
      else
        printf "${YELLOW}~ %d/%d installed (%d missing)${RESET}\n" "$installed" "$total" "$missing"
      fi
      ;;
  esac
}

# ─────────────────────────────────────────────────
# Status table
# ─────────────────────────────────────────────────

print_status_table() {
  printf "\n${BOLD}%-45s %-6s %s${RESET}\n" "FILE" "MODE" "STATUS"
  printf "${DIM}%-45s %-6s %s${RESET}\n" "─────────────────────────────────────────────" "──────" "──────────────────"

  for mapping in "${MAPPINGS[@]}"; do
    parse_mapping "$mapping"
    local status
    status="$(file_status "$REPO_PATH" "$SYS_PATH")"
    printf "%-45s ${DIM}%-6s${RESET} " "$REPO_PATH" "$MODE"
    status_color "$status"
    printf "\n"
  done

  if [[ -f "${REPO_DIR}/AGENTS.md" ]]; then
    local agents_status
    agents_status="$(file_status "AGENTS.md" "${HOME_DIR}/AGENTS.md")"
    printf "%-45s ${DIM}%-6s${RESET} " "AGENTS.md" "link"
    status_color "$agents_status"
    printf "\n"
  fi

  sync_skills "status"

  check_agents_symlink
  print_secrets_status
}

# ─────────────────────────────────────────────────
# Interactive mode
# ─────────────────────────────────────────────────

interactive_sync() {
  print_status_table
  printf "\n${BOLD}Interactive sync:${RESET}\n\n"

  for mapping in "${MAPPINGS[@]}"; do
    parse_mapping "$mapping"
    local status
    status="$(file_status "$REPO_PATH" "$SYS_PATH")"

    case "$status" in
      synced) continue ;;
      missing_both) continue ;;
    esac

    printf "${CYAN}%s${RESET} " "$REPO_PATH"
    status_color "$status"
    if [[ "$MODE" == "sensitive" ]]; then
      printf " ${DIM}(tokens auto-handled)${RESET}"
    fi
    printf "\n"

    if [[ "$status" == "diverged" ]]; then
      show_diff "$REPO_PATH" "$SYS_PATH"
      printf "\n"
    fi

    local choices=""
    case "$status" in
      diverged)
        choices="[p]ush repo->system  [l]pull system->repo  [d]iff  [s]kip"
        ;;
      missing_repo)
        choices="[l]pull system->repo  [s]kip"
        ;;
      missing_system)
        choices="[p]ush repo->system  [s]kip"
        ;;
    esac

    while true; do
      printf "  ${DIM}%s${RESET}: " "$choices"
      read -r -n 1 choice
      printf "\n"

      case "$choice" in
        p)
          if [[ "$status" == "missing_repo" ]]; then
            printf "  ${RED}Cannot push — file missing from repo${RESET}\n"
            continue
          fi
          push_to_system "$REPO_PATH" "$MODE" "$SYS_PATH"
          printf "  ${GREEN}✓ Pushed to system${RESET}\n"
          ((SYNCED++))
          break
          ;;
        l)
          if [[ "$status" == "missing_system" ]]; then
            printf "  ${RED}Cannot pull — file missing from system${RESET}\n"
            continue
          fi
          pull_to_repo "$REPO_PATH" "$MODE" "$SYS_PATH"
          printf "  ${GREEN}✓ Pulled to repo (tokens saved to %s)${RESET}\n" "$SECRETS_BACKEND"
          ((SYNCED++))
          break
          ;;
        d)
          if [[ "$status" == "diverged" ]]; then
            diff --color=always -u "${REPO_DIR}/${REPO_PATH}" "$SYS_PATH" | less -R || true
          else
            printf "  ${DIM}Nothing to diff${RESET}\n"
          fi
          ;;
        s)
          ((SKIPPED++))
          break
          ;;
        *)
          printf "  ${DIM}Invalid choice${RESET}\n"
          ;;
      esac
    done
    printf "\n"
  done

  # Handle AGENTS.md
  if [[ -f "${REPO_DIR}/AGENTS.md" ]] || [[ -f "${HOME_DIR}/AGENTS.md" ]]; then
    local agents_status
    agents_status="$(file_status "AGENTS.md" "${HOME_DIR}/AGENTS.md")"
    if [[ "$agents_status" != "synced" ]]; then
      printf "${CYAN}AGENTS.md${RESET} "
      status_color "$agents_status"
      printf "\n"
      printf "  ${DIM}[p]ush repo->system  [l]pull system->repo  [s]kip${RESET}: "
      read -r -n 1 choice
      printf "\n"
      case "$choice" in
        p) sync_agents_md "push"; ((SYNCED++)) ;;
        l) sync_agents_md "pull"; ((SYNCED++)) ;;
        *) ((SKIPPED++)) ;;
      esac
    fi
  fi

  printf "\n${BOLD}Done:${RESET} ${GREEN}%d synced${RESET}, ${YELLOW}%d skipped${RESET}, ${RED}%d errors${RESET}\n" "$SYNCED" "$SKIPPED" "$ERRORS"
}

# ─────────────────────────────────────────────────
# Batch push (repo -> system)
# ─────────────────────────────────────────────────

batch_push() {
  printf "${BOLD}Pushing all files: repo -> system${RESET}\n"
  printf "${DIM}Sensitive files: placeholders filled from %s${RESET}\n\n" "$SECRETS_BACKEND"

  for mapping in "${MAPPINGS[@]}"; do
    parse_mapping "$mapping"
    local repo_file="${REPO_DIR}/${REPO_PATH}"

    if [[ ! -f "$repo_file" ]]; then
      printf "  ${YELLOW}⚠ Skip${RESET} %s (missing from repo)\n" "$REPO_PATH"
      ((SKIPPED++))
      continue
    fi

    if diff -q "$repo_file" "$SYS_PATH" &>/dev/null 2>&1; then
      printf "  ${DIM}= %s (already synced)${RESET}\n" "$REPO_PATH"
      continue
    fi

    push_to_system "$REPO_PATH" "$MODE" "$SYS_PATH"
    printf "  ${GREEN}✓${RESET} %s\n" "$REPO_PATH"
    ((SYNCED++))
  done

  sync_agents_md "push"
  sync_skills "push"

  printf "\n${BOLD}Done:${RESET} ${GREEN}%d synced${RESET}, ${YELLOW}%d skipped${RESET}, ${RED}%d errors${RESET}\n" "$SYNCED" "$SKIPPED" "$ERRORS"
}

# ─────────────────────────────────────────────────
# Batch pull (system -> repo)
# ─────────────────────────────────────────────────

batch_pull() {
  printf "${BOLD}Pulling all files: system -> repo${RESET}\n"
  printf "${DIM}Sensitive files: tokens saved to %s, replaced with placeholders${RESET}\n\n" "$SECRETS_BACKEND"

  for mapping in "${MAPPINGS[@]}"; do
    parse_mapping "$mapping"

    if [[ ! -f "$SYS_PATH" ]]; then
      printf "  ${YELLOW}⚠ Skip${RESET} %s (missing from system)\n" "$REPO_PATH"
      ((SKIPPED++))
      continue
    fi

    if diff -q "${REPO_DIR}/${REPO_PATH}" "$SYS_PATH" &>/dev/null 2>&1; then
      printf "  ${DIM}= %s (already synced)${RESET}\n" "$REPO_PATH"
      continue
    fi

    pull_to_repo "$REPO_PATH" "$MODE" "$SYS_PATH"
    printf "  ${GREEN}✓${RESET} %s\n" "$REPO_PATH"
    ((SYNCED++))
  done

  sync_agents_md "pull"
  sync_skills "pull"

  printf "\n${BOLD}Done:${RESET} ${GREEN}%d synced${RESET}, ${YELLOW}%d skipped${RESET}, ${RED}%d errors${RESET}\n" "$SYNCED" "$SKIPPED" "$ERRORS"
}

# ─────────────────────────────────────────────────
# Usage
# ─────────────────────────────────────────────────

usage() {
  printf "${BOLD}sync${RESET} — bidirectional dotfile synchronization\n"
  printf "\n${BOLD}Usage:${RESET}\n"
  printf "  ./sync            Interactive mode (per-file prompts)\n"
  printf "  ./sync --status   Show status table and secrets backend\n"
  printf "  ./sync --push     Batch push: repo -> system\n"
  printf "  ./sync --pull     Batch pull: system -> repo\n"
  printf "  ./sync --help     Show this help\n"
  printf "\n${BOLD}Token handling:${RESET}\n"
  printf "  Sensitive files are automatically sanitized in both directions.\n"
  printf "  Real values are persisted so they survive across syncs:\n"
  printf "  • Pull: tokens saved to secrets backend, replaced with placeholders\n"
  printf "  • Push: placeholders filled from secrets backend (or system file)\n"
  printf "\n${BOLD}Token resolution (push, in priority order):${RESET}\n"
  printf "  1. Secrets backend (1Password item or local file vault)\n"
  printf "  2. Current system file values\n"
  printf "  3. .sync_config op:// references (for fresh machine bootstrap)\n"
  printf "\n${BOLD}Secrets backends:${RESET}\n"
  printf "  1. 1Password CLI — encrypted, syncs across machines\n"
  printf "     Requires: brew install --cask 1password-cli\n"
  printf "     Override vault: DOTFILES_OP_VAULT=MyVault ./sync\n"
  printf "  2. Local file vault — .sync_vault/ (gitignored fallback)\n"
  printf "\n${BOLD}Fresh machine setup:${RESET}\n"
  printf "  Edit .sync_config with your op:// references, then run ./sync --push\n"
  printf "  Tokens will be resolved from your existing 1Password items.\n"
  printf "\n${BOLD}Tracked files:${RESET}\n"
  for mapping in "${MAPPINGS[@]}"; do
    parse_mapping "$mapping"
    printf "  %-40s -> %s ${DIM}(%s)${RESET}\n" "$REPO_PATH" "$SYS_PATH" "$MODE"
  done
  printf "  %-40s -> %s ${DIM}(link)${RESET}\n" "AGENTS.md" "~/AGENTS.md + ~/.claude/CLAUDE.md"
}

# ─────────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────────

main() {
  secrets_init

  local mode="${1:-interactive}"

  case "$mode" in
    --status)       print_status_table ;;
    --push)         batch_push ;;
    --pull)         batch_pull ;;
    --help|-h)      usage ;;
    interactive|"") interactive_sync ;;
    *)
      printf "${RED}Unknown option: %s${RESET}\n" "$mode"
      usage
      exit 1
      ;;
  esac
}

main "$@"
