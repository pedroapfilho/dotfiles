#!/usr/bin/env bash
set -euo pipefail

# ─────────────────────────────────────────────────
# sync — bidirectional dotfile synchronization
# ─────────────────────────────────────────────────

REPO_DIR="$(cd "$(dirname "$0")" && pwd)"
HOME_DIR="$HOME"
VAULT_DIR="${REPO_DIR}/.sync_vault"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
RESET='\033[0m'

# Counters
SYNCED=0
SKIPPED=0
ERRORS=0

# Token patterns to detect secrets (safety net validation)
SECRET_PATTERNS='ghp_[A-Za-z0-9]|github_pat_[A-Za-z0-9]|npm_[A-Za-z0-9]{10}|sk-[A-Za-z0-9]{10}|ctx7sk-[A-Za-z0-9]|ghs_[A-Za-z0-9]|glpat-[A-Za-z0-9]|xox[bpsar]-[A-Za-z0-9]|ssh-ed25519 AAAA[A-Za-z0-9]'

# ─────────────────────────────────────────────────
# File mappings: repo_path:system_path:mode
# mode = copy | sensitive
# ─────────────────────────────────────────────────
MAPPINGS=(
  ".zshrc:${HOME_DIR}/.zshrc:sensitive"
  ".gitconfig:${HOME_DIR}/.gitconfig:sensitive"
  ".gitignore:${HOME_DIR}/.gitignore:copy"
  ".claude/settings.json:${HOME_DIR}/.claude/settings.json:copy"
  ".claude/mcp.json:${HOME_DIR}/.claude/mcp.json:copy"
  ".claude/agents/backend-architect.md:${HOME_DIR}/.claude/agents/backend-architect.md:copy"
  ".claude/agents/code-reviewer.md:${HOME_DIR}/.claude/agents/code-reviewer.md:copy"
  ".claude/agents/context-manager.md:${HOME_DIR}/.claude/agents/context-manager.md:copy"
  ".claude/agents/frontend-architect.md:${HOME_DIR}/.claude/agents/frontend-architect.md:copy"
  ".claude/agents/react-component-architect.md:${HOME_DIR}/.claude/agents/react-component-architect.md:copy"
  ".claude/agents/react-nextjs-expert.md:${HOME_DIR}/.claude/agents/react-nextjs-expert.md:copy"
  ".claude/commands/aw.md:${HOME_DIR}/.claude/commands/aw.md:copy"
  ".claude/hooks/pre-tool-use.js:${HOME_DIR}/.claude/hooks/pre-tool-use.js:copy"
  ".codex/config.toml:${HOME_DIR}/.codex/config.toml:sensitive"
  ".config/zed/settings.json:${HOME_DIR}/.config/zed/settings.json:copy"
  ".config/zed/keymap.json:${HOME_DIR}/.config/zed/keymap.json:copy"
  ".config/spaceship.zsh:${HOME_DIR}/.config/spaceship.zsh:copy"
  ".config/git/ignore:${HOME_DIR}/.config/git/ignore:copy"
  ".ssh/config:${HOME_DIR}/.ssh/config:sensitive"
)

# ─────────────────────────────────────────────────
# Helpers
# ─────────────────────────────────────────────────

cleanup() {
  printf "\n${DIM}Interrupted. ${SYNCED} synced, ${SKIPPED} skipped, ${ERRORS} errors.${RESET}\n"
  exit 130
}
trap cleanup SIGINT

parse_mapping() {
  local mapping="$1"
  REPO_PATH="${mapping%%:*}"
  local rest="${mapping#*:}"
  SYS_PATH="${rest%%:*}"
  MODE="${rest##*:}"
}

file_status() {
  local repo_file="${REPO_DIR}/${1}"
  local sys_file="$2"

  if [[ ! -f "$repo_file" ]] && [[ ! -f "$sys_file" ]]; then
    echo "missing_both"
  elif [[ ! -f "$repo_file" ]]; then
    echo "missing_repo"
  elif [[ ! -f "$sys_file" ]]; then
    echo "missing_system"
  elif diff -q "$repo_file" "$sys_file" &>/dev/null; then
    echo "synced"
  else
    echo "diverged"
  fi
}

status_color() {
  case "$1" in
    synced)        printf "${GREEN}✓ synced${RESET}" ;;
    diverged)      printf "${YELLOW}~ diverged${RESET}" ;;
    missing_repo)  printf "${RED}✗ missing in repo${RESET}" ;;
    missing_system) printf "${RED}✗ missing on system${RESET}" ;;
    missing_both)  printf "${RED}✗ missing both${RESET}" ;;
  esac
}

has_secrets() {
  grep -qE "$SECRET_PATTERNS" "$1" 2>/dev/null
}

show_diff() {
  local repo_file="${REPO_DIR}/${1}"
  local sys_file="$2"
  local lines="${3:-20}"

  if [[ -f "$repo_file" ]] && [[ -f "$sys_file" ]]; then
    diff --color=always -u "$repo_file" "$sys_file" | head -n "$lines" || true
    local total
    total=$(diff -u "$repo_file" "$sys_file" 2>/dev/null | wc -l | tr -d ' ')
    if (( total > lines )); then
      printf "${DIM}  ... %d more lines (showing %d/%d)${RESET}\n" $((total - lines)) "$lines" "$total"
    fi
  fi
}

ensure_parent_dir() {
  local dir
  dir="$(dirname "$1")"
  if [[ ! -d "$dir" ]]; then
    mkdir -p "$dir"
    printf "  ${DIM}Created directory: %s${RESET}\n" "$dir"
  fi
}

is_token_var() {
  local var="$1"
  case "$var" in
    *_TOKEN|*_SECRET|*_API_KEY|*_APIKEY|*_KEY) return 0 ;;
    TOKEN|SECRET|API_KEY|APIKEY) return 0 ;;
    *) return 1 ;;
  esac
}

# ─────────────────────────────────────────────────
# Vault — persists real token values across syncs
#
# Structure:
#   .sync_vault/
#     zshrc/GITHUB_TOKEN    (raw export lines)
#     zshrc/NPM_TOKEN
#     gitconfig/signingkey  (value only)
#     gitconfig/name
#     gitconfig/email
#     gitconfig/excludesfile
#     codex/CONTEXT7_API_KEY
# ─────────────────────────────────────────────────

vault_save() {
  local category="$1"
  local key="$2"
  local value="$3"
  local dir="${VAULT_DIR}/${category}"
  mkdir -p "$dir"
  if [[ -n "$value" ]]; then
    printf '%s\n' "$value" > "${dir}/${key}"
  fi
}

vault_append() {
  local category="$1"
  local key="$2"
  local value="$3"
  local dir="${VAULT_DIR}/${category}"
  mkdir -p "$dir"
  printf '%s\n' "$value" >> "${dir}/${key}"
}

vault_get() {
  local category="$1"
  local key="$2"
  local file="${VAULT_DIR}/${category}/${key}"
  if [[ -f "$file" && -s "$file" ]]; then
    cat "$file"
    return 0
  fi
  return 1
}

vault_clear_category() {
  local category="$1"
  rm -rf "${VAULT_DIR:?}/${category}"
}

print_vault_status() {
  if [[ ! -d "$VAULT_DIR" ]]; then
    printf "\n${BOLD}Vault:${RESET} ${DIM}empty (run a pull to populate)${RESET}\n"
    return
  fi

  printf "\n${BOLD}Vault:${RESET} ${DIM}%s${RESET}\n" "$VAULT_DIR"
  local count=0
  for category_dir in "${VAULT_DIR}"/*/; do
    [[ -d "$category_dir" ]] || continue
    local category
    category="$(basename "$category_dir")"
    for key_file in "${category_dir}"*; do
      [[ -f "$key_file" ]] || continue
      local key
      key="$(basename "$key_file")"
      local preview
      preview="$(head -c 40 "$key_file" | tr '\n' ' ')"
      printf "  ${DIM}%s/%s${RESET} = ${DIM}%.30s...${RESET}\n" "$category" "$key" "$preview"
      ((count++))
    done
  done
  if (( count == 0 )); then
    printf "  ${DIM}(no values stored)${RESET}\n"
  fi
}

# ─────────────────────────────────────────────────
# Token sanitization (pull: system → repo)
#
# Strips real tokens, replaces with placeholders,
# and saves real values to the vault.
# ─────────────────────────────────────────────────

sanitize_for_repo() {
  local repo_path="$1"
  local src="$2"

  case "$repo_path" in
    .zshrc)
      sanitize_zshrc "$src"
      ;;
    .gitconfig)
      sanitize_gitconfig "$src"
      ;;
    .codex/config.toml)
      sanitize_codex "$src"
      ;;
    .ssh/config)
      cat "$src"
      ;;
    *)
      cat "$src"
      ;;
  esac
}

sanitize_zshrc() {
  local src="$1"
  local seen=":"

  # Clear previous vault entries for zshrc
  vault_clear_category "zshrc"

  while IFS= read -r line || [[ -n "$line" ]]; do
    # Extract variable name from export lines (handles # prefix)
    local var=""
    if [[ "$line" =~ ^[#[:space:]]*(export[[:space:]]+([A-Z_]+)=) ]]; then
      var="${BASH_REMATCH[2]}"
    fi

    if [[ -n "$var" ]] && is_token_var "$var"; then
      if [[ ":$seen:" != *":$var:"* ]]; then
        # First occurrence: save to vault, emit placeholder
        vault_save "zshrc" "$var" "$line"
        seen="${seen}${var}:"
        local placeholder
        placeholder="$(echo "$var" | tr '[:upper:]' '[:lower:]')"
        echo "# export ${var}=your_${placeholder}_here"
      else
        # Subsequent occurrence: append to vault, skip output
        vault_append "zshrc" "$var" "$line"
      fi
    elif [[ "$line" =~ ^#[[:space:]]*envs ]]; then
      echo "# envs - ADD YOUR OWN TOKENS HERE"
    else
      echo "$line"
    fi
  done < "$src"
}

sanitize_gitconfig() {
  local src="$1"

  # Save real values to vault
  vault_clear_category "gitconfig"
  local val
  val="$(git config --file "$src" user.signingkey 2>/dev/null || true)"
  [[ -n "$val" ]] && vault_save "gitconfig" "signingkey" "$val"
  val="$(git config --file "$src" user.name 2>/dev/null || true)"
  [[ -n "$val" ]] && vault_save "gitconfig" "name" "$val"
  val="$(git config --file "$src" user.email 2>/dev/null || true)"
  [[ -n "$val" ]] && vault_save "gitconfig" "email" "$val"
  val="$(git config --file "$src" core.excludesfile 2>/dev/null || true)"
  [[ -n "$val" ]] && vault_save "gitconfig" "excludesfile" "$val"

  # Sanitize
  sed -E \
    -e 's/^([[:space:]]*signingkey = ).+$/\1signingkey/' \
    -e 's/^([[:space:]]*name = ).+$/\1Your Name/' \
    -e 's/^([[:space:]]*email = ).+$/\1your@email.com/' \
    -e 's|^([[:space:]]*excludesfile = /Users/)[^/]+(/.*)|\1USER_NAME\2|' \
    "$src"
}

sanitize_codex() {
  local src="$1"

  # Save real API key to vault
  vault_clear_category "codex"
  local api_key
  api_key="$(grep -oE 'CONTEXT7_API_KEY[[:space:]]*=[[:space:]]*"[^"]*"' "$src" 2>/dev/null | grep -oE '"[^"]+"' | tail -1 | tr -d '"' || true)"
  if [[ -n "$api_key" && "$api_key" != "CONTEXT7_API_KEY" ]]; then
    vault_save "codex" "CONTEXT7_API_KEY" "$api_key"
  fi

  # Sanitize
  sed -E \
    -e 's/(CONTEXT7_API_KEY[[:space:]]*=[[:space:]]*)"[^"]*"/\1"CONTEXT7_API_KEY"/' \
    "$src"
}

# ─────────────────────────────────────────────────
# Token restoration (push: repo → system)
#
# Takes the repo file (placeholders) and fills in
# real values from the vault (primary) or current
# system file (fallback).
# ─────────────────────────────────────────────────

restore_for_system() {
  local repo_path="$1"
  local repo_file="$2"
  local sys_file="$3"

  case "$repo_path" in
    .zshrc)
      restore_zshrc "$repo_file" "$sys_file"
      ;;
    .gitconfig)
      restore_gitconfig "$repo_file" "$sys_file"
      ;;
    .codex/config.toml)
      restore_codex "$repo_file" "$sys_file"
      ;;
    .ssh/config)
      cat "$repo_file"
      ;;
    *)
      cat "$repo_file"
      ;;
  esac
}

restore_zshrc() {
  local repo_file="$1"
  local sys_file="$2"

  while IFS= read -r line || [[ -n "$line" ]]; do
    # Match placeholder lines: # export VARNAME=your_..._here
    if [[ "$line" =~ ^#[[:space:]]*export[[:space:]]+([A-Z_]+)=your_.*_here$ ]]; then
      local var="${BASH_REMATCH[1]}"
      local restored=""

      # Try vault first
      restored="$(vault_get zshrc "$var" 2>/dev/null || true)"

      # Fall back to system file
      if [[ -z "$restored" && -f "$sys_file" ]]; then
        restored="$(grep -E "^[#[:space:]]*(export[[:space:]]+${var}=)" "$sys_file" 2>/dev/null || true)"
      fi

      if [[ -n "$restored" ]]; then
        echo "$restored"
      else
        echo "$line"
      fi
    elif [[ "$line" == "# envs - ADD YOUR OWN TOKENS HERE" ]]; then
      echo "# envs"
    else
      echo "$line"
    fi
  done < "$repo_file"
}

restore_gitconfig() {
  local repo_file="$1"
  local sys_file="$2"
  local tmpfile
  tmpfile="$(mktemp)"
  cp "$repo_file" "$tmpfile"

  # Read from vault first, fall back to system
  local signingkey name email excludesfile

  signingkey="$(vault_get gitconfig signingkey 2>/dev/null || true)"
  if [[ -z "$signingkey" && -f "$sys_file" ]]; then
    signingkey="$(git config --file "$sys_file" user.signingkey 2>/dev/null || true)"
  fi

  name="$(vault_get gitconfig name 2>/dev/null || true)"
  if [[ -z "$name" && -f "$sys_file" ]]; then
    name="$(git config --file "$sys_file" user.name 2>/dev/null || true)"
  fi

  email="$(vault_get gitconfig email 2>/dev/null || true)"
  if [[ -z "$email" && -f "$sys_file" ]]; then
    email="$(git config --file "$sys_file" user.email 2>/dev/null || true)"
  fi

  excludesfile="$(vault_get gitconfig excludesfile 2>/dev/null || true)"
  if [[ -z "$excludesfile" && -f "$sys_file" ]]; then
    excludesfile="$(git config --file "$sys_file" core.excludesfile 2>/dev/null || true)"
  fi

  [[ -n "$signingkey" ]] && git config --file "$tmpfile" user.signingkey "$signingkey"
  [[ -n "$name" ]] && git config --file "$tmpfile" user.name "$name"
  [[ -n "$email" ]] && git config --file "$tmpfile" user.email "$email"
  [[ -n "$excludesfile" ]] && git config --file "$tmpfile" core.excludesfile "$excludesfile"

  cat "$tmpfile"
  rm -f "$tmpfile"
}

restore_codex() {
  local repo_file="$1"
  local sys_file="$2"

  local api_key
  api_key="$(vault_get codex CONTEXT7_API_KEY 2>/dev/null || true)"

  if [[ -z "$api_key" || "$api_key" == "CONTEXT7_API_KEY" ]]; then
    if [[ -f "$sys_file" ]]; then
      api_key="$(grep -oE 'CONTEXT7_API_KEY[[:space:]]*=[[:space:]]*"[^"]*"' "$sys_file" 2>/dev/null | grep -oE '"[^"]+"' | tail -1 | tr -d '"' || true)"
    fi
  fi

  if [[ -n "$api_key" && "$api_key" != "CONTEXT7_API_KEY" ]]; then
    sed "s|CONTEXT7_API_KEY = \"CONTEXT7_API_KEY\"|CONTEXT7_API_KEY = \"${api_key}\"|" "$repo_file"
  else
    cat "$repo_file"
  fi
}

# ─────────────────────────────────────────────────
# Smart copy: handles sanitization/restoration
# ─────────────────────────────────────────────────

push_to_system() {
  local repo_path="$1"
  local mode="$2"
  local repo_file="${REPO_DIR}/${repo_path}"
  local sys_file="$3"

  ensure_parent_dir "$sys_file"

  if [[ "$mode" == "sensitive" ]]; then
    restore_for_system "$repo_path" "$repo_file" "$sys_file" > "${sys_file}.sync_tmp"
    mv "${sys_file}.sync_tmp" "$sys_file"
  else
    cp "$repo_file" "$sys_file"
  fi
}

pull_to_repo() {
  local repo_path="$1"
  local mode="$2"
  local sys_file="$3"
  local repo_file="${REPO_DIR}/${repo_path}"

  ensure_parent_dir "$repo_file"

  if [[ "$mode" == "sensitive" ]]; then
    sanitize_for_repo "$repo_path" "$sys_file" > "${repo_file}.sync_tmp"
    mv "${repo_file}.sync_tmp" "$repo_file"

    # Safety net: verify no secrets leaked through
    if has_secrets "$repo_file"; then
      printf "  ${RED}⚠ WARNING: Secrets detected after sanitization in %s${RESET}\n" "$repo_path"
      printf "  ${RED}  Review the file before committing!${RESET}\n"
    fi
  else
    cp "$sys_file" "$repo_file"
  fi
}

# ─────────────────────────────────────────────────
# AGENTS.md / CLAUDE.md symlink
# ─────────────────────────────────────────────────

check_agents_symlink() {
  local agents_repo="${REPO_DIR}/AGENTS.md"
  local agents_home="${HOME_DIR}/AGENTS.md"
  local claude_link="${HOME_DIR}/.claude/CLAUDE.md"

  printf "\n${BOLD}AGENTS.md symlink health:${RESET}\n"

  if [[ -f "$agents_repo" ]]; then
    if [[ -f "$agents_home" ]]; then
      if diff -q "$agents_repo" "$agents_home" &>/dev/null; then
        printf "  ${GREEN}✓${RESET} ~/AGENTS.md in sync with repo\n"
      else
        printf "  ${YELLOW}~${RESET} ~/AGENTS.md diverged from repo\n"
      fi
    else
      printf "  ${RED}✗${RESET} ~/AGENTS.md missing\n"
    fi
  else
    printf "  ${RED}✗${RESET} AGENTS.md missing from repo\n"
  fi

  if [[ -L "$claude_link" ]]; then
    local target
    target="$(readlink "$claude_link")"
    if [[ "$target" == "${HOME_DIR}/AGENTS.md" ]] || [[ "$target" == "$agents_home" ]]; then
      printf "  ${GREEN}✓${RESET} ~/.claude/CLAUDE.md -> ~/AGENTS.md\n"
    else
      printf "  ${YELLOW}~${RESET} ~/.claude/CLAUDE.md -> %s (unexpected target)\n" "$target"
    fi
  elif [[ -f "$claude_link" ]]; then
    printf "  ${RED}✗${RESET} ~/.claude/CLAUDE.md is a regular file (should be symlink)\n"
  else
    printf "  ${RED}✗${RESET} ~/.claude/CLAUDE.md symlink missing\n"
  fi
}

sync_agents_md() {
  local direction="$1"
  local agents_repo="${REPO_DIR}/AGENTS.md"
  local agents_home="${HOME_DIR}/AGENTS.md"
  local claude_link="${HOME_DIR}/.claude/CLAUDE.md"

  case "$direction" in
    push)
      if [[ -f "$agents_repo" ]]; then
        cp "$agents_repo" "$agents_home"
        printf "  ${GREEN}✓${RESET} Copied AGENTS.md -> ~/AGENTS.md\n"
      fi
      ;;
    pull)
      if [[ -f "$agents_home" ]]; then
        cp "$agents_home" "$agents_repo"
        printf "  ${GREEN}✓${RESET} Copied ~/AGENTS.md -> repo AGENTS.md\n"
      fi
      ;;
  esac

  if [[ ! -L "$claude_link" ]]; then
    rm -f "$claude_link"
    mkdir -p "$(dirname "$claude_link")"
    ln -s "${HOME_DIR}/AGENTS.md" "$claude_link"
    printf "  ${GREEN}✓${RESET} Created symlink ~/.claude/CLAUDE.md -> ~/AGENTS.md\n"
  fi
}

# ─────────────────────────────────────────────────
# Status table
# ─────────────────────────────────────────────────

print_status_table() {
  printf "\n${BOLD}%-45s %-6s %s${RESET}\n" "FILE" "MODE" "STATUS"
  printf "${DIM}%-45s %-6s %s${RESET}\n" "─────────────────────────────────────────────" "──────" "──────────────────"

  for mapping in "${MAPPINGS[@]}"; do
    parse_mapping "$mapping"
    local status
    status="$(file_status "$REPO_PATH" "$SYS_PATH")"
    printf "%-45s ${DIM}%-6s${RESET} " "$REPO_PATH" "$MODE"
    status_color "$status"
    printf "\n"
  done

  if [[ -f "${REPO_DIR}/AGENTS.md" ]]; then
    local agents_status
    agents_status="$(file_status "AGENTS.md" "${HOME_DIR}/AGENTS.md")"
    printf "%-45s ${DIM}%-6s${RESET} " "AGENTS.md" "link"
    status_color "$agents_status"
    printf "\n"
  fi

  check_agents_symlink
  print_vault_status
}

# ─────────────────────────────────────────────────
# Interactive mode
# ─────────────────────────────────────────────────

interactive_sync() {
  print_status_table
  printf "\n${BOLD}Interactive sync:${RESET}\n\n"

  for mapping in "${MAPPINGS[@]}"; do
    parse_mapping "$mapping"
    local status
    status="$(file_status "$REPO_PATH" "$SYS_PATH")"

    case "$status" in
      synced) continue ;;
      missing_both) continue ;;
    esac

    printf "${CYAN}%s${RESET} " "$REPO_PATH"
    status_color "$status"
    if [[ "$MODE" == "sensitive" ]]; then
      printf " ${DIM}(tokens auto-handled)${RESET}"
    fi
    printf "\n"

    if [[ "$status" == "diverged" ]]; then
      show_diff "$REPO_PATH" "$SYS_PATH"
      printf "\n"
    fi

    local choices=""
    case "$status" in
      diverged)
        choices="[p]ush repo->system  [l]pull system->repo  [d]iff  [s]kip"
        ;;
      missing_repo)
        choices="[l]pull system->repo  [s]kip"
        ;;
      missing_system)
        choices="[p]ush repo->system  [s]kip"
        ;;
    esac

    while true; do
      printf "  ${DIM}%s${RESET}: " "$choices"
      read -r -n 1 choice
      printf "\n"

      case "$choice" in
        p)
          if [[ "$status" == "missing_repo" ]]; then
            printf "  ${RED}Cannot push — file missing from repo${RESET}\n"
            continue
          fi
          push_to_system "$REPO_PATH" "$MODE" "$SYS_PATH"
          printf "  ${GREEN}✓ Pushed to system${RESET}\n"
          ((SYNCED++))
          break
          ;;
        l)
          if [[ "$status" == "missing_system" ]]; then
            printf "  ${RED}Cannot pull — file missing from system${RESET}\n"
            continue
          fi
          pull_to_repo "$REPO_PATH" "$MODE" "$SYS_PATH"
          printf "  ${GREEN}✓ Pulled to repo (tokens saved to vault)${RESET}\n"
          ((SYNCED++))
          break
          ;;
        d)
          if [[ "$status" == "diverged" ]]; then
            diff --color=always -u "${REPO_DIR}/${REPO_PATH}" "$SYS_PATH" | less -R || true
          else
            printf "  ${DIM}Nothing to diff${RESET}\n"
          fi
          ;;
        s)
          ((SKIPPED++))
          break
          ;;
        *)
          printf "  ${DIM}Invalid choice${RESET}\n"
          ;;
      esac
    done
    printf "\n"
  done

  # Handle AGENTS.md
  if [[ -f "${REPO_DIR}/AGENTS.md" ]] || [[ -f "${HOME_DIR}/AGENTS.md" ]]; then
    local agents_status
    agents_status="$(file_status "AGENTS.md" "${HOME_DIR}/AGENTS.md")"
    if [[ "$agents_status" != "synced" ]]; then
      printf "${CYAN}AGENTS.md${RESET} "
      status_color "$agents_status"
      printf "\n"
      printf "  ${DIM}[p]ush repo->system  [l]pull system->repo  [s]kip${RESET}: "
      read -r -n 1 choice
      printf "\n"
      case "$choice" in
        p) sync_agents_md "push"; ((SYNCED++)) ;;
        l) sync_agents_md "pull"; ((SYNCED++)) ;;
        *) ((SKIPPED++)) ;;
      esac
    fi
  fi

  printf "\n${BOLD}Done:${RESET} ${GREEN}%d synced${RESET}, ${YELLOW}%d skipped${RESET}, ${RED}%d errors${RESET}\n" "$SYNCED" "$SKIPPED" "$ERRORS"
}

# ─────────────────────────────────────────────────
# Batch push (repo -> system)
# ─────────────────────────────────────────────────

batch_push() {
  printf "${BOLD}Pushing all files: repo -> system${RESET}\n"
  printf "${DIM}Sensitive files: placeholders filled from vault / current system${RESET}\n\n"

  for mapping in "${MAPPINGS[@]}"; do
    parse_mapping "$mapping"
    local repo_file="${REPO_DIR}/${REPO_PATH}"

    if [[ ! -f "$repo_file" ]]; then
      printf "  ${YELLOW}⚠ Skip${RESET} %s (missing from repo)\n" "$REPO_PATH"
      ((SKIPPED++))
      continue
    fi

    if diff -q "$repo_file" "$SYS_PATH" &>/dev/null 2>&1; then
      printf "  ${DIM}= %s (already synced)${RESET}\n" "$REPO_PATH"
      continue
    fi

    push_to_system "$REPO_PATH" "$MODE" "$SYS_PATH"
    printf "  ${GREEN}✓${RESET} %s\n" "$REPO_PATH"
    ((SYNCED++))
  done

  sync_agents_md "push"

  printf "\n${BOLD}Done:${RESET} ${GREEN}%d synced${RESET}, ${YELLOW}%d skipped${RESET}, ${RED}%d errors${RESET}\n" "$SYNCED" "$SKIPPED" "$ERRORS"
}

# ─────────────────────────────────────────────────
# Batch pull (system -> repo)
# ─────────────────────────────────────────────────

batch_pull() {
  printf "${BOLD}Pulling all files: system -> repo${RESET}\n"
  printf "${DIM}Sensitive files: tokens saved to vault, replaced with placeholders${RESET}\n\n"

  for mapping in "${MAPPINGS[@]}"; do
    parse_mapping "$mapping"

    if [[ ! -f "$SYS_PATH" ]]; then
      printf "  ${YELLOW}⚠ Skip${RESET} %s (missing from system)\n" "$REPO_PATH"
      ((SKIPPED++))
      continue
    fi

    if diff -q "${REPO_DIR}/${REPO_PATH}" "$SYS_PATH" &>/dev/null 2>&1; then
      printf "  ${DIM}= %s (already synced)${RESET}\n" "$REPO_PATH"
      continue
    fi

    pull_to_repo "$REPO_PATH" "$MODE" "$SYS_PATH"
    printf "  ${GREEN}✓${RESET} %s\n" "$REPO_PATH"
    ((SYNCED++))
  done

  sync_agents_md "pull"

  printf "\n${BOLD}Done:${RESET} ${GREEN}%d synced${RESET}, ${YELLOW}%d skipped${RESET}, ${RED}%d errors${RESET}\n" "$SYNCED" "$SKIPPED" "$ERRORS"
}

# ─────────────────────────────────────────────────
# Usage
# ─────────────────────────────────────────────────

usage() {
  printf "${BOLD}sync${RESET} — bidirectional dotfile synchronization\n"
  printf "\n${BOLD}Usage:${RESET}\n"
  printf "  ./sync            Interactive mode (per-file prompts)\n"
  printf "  ./sync --status   Show status table and vault contents\n"
  printf "  ./sync --push     Batch push: repo -> system\n"
  printf "  ./sync --pull     Batch pull: system -> repo\n"
  printf "  ./sync --help     Show this help\n"
  printf "\n${BOLD}Token handling:${RESET}\n"
  printf "  Sensitive files are automatically sanitized in both directions.\n"
  printf "  Real values are persisted in .sync_vault/ (gitignored) so they\n"
  printf "  survive across syncs:\n"
  printf "  • Pull: tokens saved to vault, then replaced with placeholders\n"
  printf "  • Push: placeholders filled from vault (or current system file)\n"
  printf "\n${BOLD}Tracked files:${RESET}\n"
  for mapping in "${MAPPINGS[@]}"; do
    parse_mapping "$mapping"
    printf "  %-40s -> %s ${DIM}(%s)${RESET}\n" "$REPO_PATH" "$SYS_PATH" "$MODE"
  done
  printf "  %-40s -> %s ${DIM}(link)${RESET}\n" "AGENTS.md" "~/AGENTS.md + ~/.claude/CLAUDE.md"
}

# ─────────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────────

main() {
  local mode="${1:-interactive}"

  case "$mode" in
    --status)
      print_status_table
      ;;
    --push)
      batch_push
      ;;
    --pull)
      batch_pull
      ;;
    --help|-h)
      usage
      ;;
    interactive|"")
      interactive_sync
      ;;
    *)
      printf "${RED}Unknown option: %s${RESET}\n" "$mode"
      usage
      exit 1
      ;;
  esac
}

main "$@"
